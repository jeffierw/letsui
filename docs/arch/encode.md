---
sidebar_position: 2
---

# 编码

- Walrus 采用擦除码编码 (Erasure Code) 算法会将一个数据块（blob）分割成若干个符号（k），然后将其编码成 (n>k) 个符号，这样这些 (n) 个符号中的一个子集就可以用来重建这个blob。

  - 比如Walrus使用的高效的擦除码编码算法可以通过三分之一的符号k来重建 blob 数据。

  - 对于每个 blob，多个符号k被组合成一个 sliver 碎片，然后将其分配给一个分片shard。

  - 存储节点管理一个或多个分片，每个blob对应的分片会分布到所有存储分片上。

  - 详细的编码设置会导致 blob 大小扩大 4.5∼5倍。这与分片数量和存储节点数量无关。

- 每个 Blob对象 还与一些元数据相关联，包括用于验证的Blob ID ：

  - Blob ID 被用来为所有分片数据和元数据（字节大小、编码、Blob 哈希）集的验证id。

  - Walrus 对每个分片中的碎片进行哈希处理，并将生成的哈希值添加到 Merkle 树中。那么 Merkle 树的根就是 Blob 哈希值，用于导出在系统中标识 Blob对象 的 Blob ID。

  - 每个存储节点都可以使用 Blob ID 来检查某些分片数据是否属于 Blob，并与Blob 哈希（Merkle 树）对应的经过身份验证的结构同步。成功的检查意味着数据确实符合 Blob 上传者的预期。

  - 由于 上传 Blob 的人可能错误地编码了 Blob（错误或故意），因此从分片重建 Blob ID 的任何一方都必须检查它是否编码为正确的 Blob ID。

  - 此过程涉及使用纠删码重新编码 blob，并再次派生 blob ID 以检查 blob 是否匹配。这可以防止任何正确的接收者将格式错误的 blob（错误的纠删码）读取为有效的 blob。



